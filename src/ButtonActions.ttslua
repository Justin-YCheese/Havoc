--[[
ButtonActions.ttslua START

This file contains functions that buttons directly trigger.
]]

-- Deal 4 cards to both players, spawn buttons, and start planning phase
function dealCards()
  log('deal')
  dealDeck(4)
  button.clearButtons() -- Remove Deal and Deck Builder buttons
  createBetButtons()
  createResultsButton()
  createClearButton()
  createSumButtons()
  gameStarted = true
end

-- Puts cards in field into player 1's win pile
function results(obj, color, alt_click)
  if players[color] == nil then
    broadcastToAll(PLAYER_HAS_NO_COLOR_BROADCAST_MESSAGE)
    log(PLAYER_HAS_NO_COLOR_LOG_MESSAGE)
    return
  end

  -- local message = 'Player '..color..' Wins!'
  -- broadcastToAll(message)
  -- log(message)
  local zoneObjects = fieldZone.getObjects()
  local i = 0
  local winPlacement = players[color].winPile.getPosition()

  -- Calculate, Broadcast, and Record gained points & bonuses
  resultAddedPoints(color,zoneObjects) -- True for returning messages
  --table.insert(record['points'],points)

  --log('Testing Win Pile: '..players[color].winPile.getGUID())
  --log('Win Pile Position: '..winPlacement[1]..' '..winPlacement[2]..' '..winPlacement[3])
  for _, item in ipairs(zoneObjects) do -- Check each object in the zone
    if #item.getZones() == 2 then     -- If in only field zone and the zone surrounding the whole game (so doesn't grab deck)
        item.setPositionSmooth({winPlacement[1], winPlacement[2]+5+i, winPlacement[3]}, false, true) -- Put cards above win pile at varyisng heights
        i = i + .8
    end
  end

  regenerateBetButtons()
end

-- Returns points earned from adding cards to winner
-- Given the player that won and cards that will be added
-- Doesn't work for decks in the field
function resultAddedPoints(playerColor,zoneObjects) --playerColor,zoneObjects
  -- local playerColor = 'Blue'
  -- local zoneObjects = fieldZone.getObjects()
  local player = players[playerColor]
  -- local sum = 0
  local numofCards = 0
  local cardTable = {}
  local bonusCards = {}
  local initialPoints = calculatePoints(player.wonCards)
  local backupMessage = '' -- Kept empty if there was no backup
  -- Copy values without referance
  for name, cards in pairs(player.wonCards) do
    cardTable[name] = player.wonCards[name]
  end
  -- simulates 'adding' cards from field to wonCards (doesn't actually change wonCards)
  for _, item in pairs(zoneObjects) do
    if #item.getZones() == 2 and item.tag == 'Card' then -- If a card is in only 2 zones (FieldZone and DeckBuilder | So not the deck)
      numofCards = numofCards + 1
      local name = item.getName()
      if cardTable[name] == nil then -- If not counted yet
        cardTable[name] = 1
      else -- If already counted
        cardTable[name] = cardTable[name] + 1
        -- Record 4 of a kind
        if cardTable[name] == 4 then
          --log('Found 4 of a kind: '..name)
          table.insert(bonusCards, name)
          if not player.backup then
            player.backup = true
            backupMessage = 'and got Backup!'
          end
        end
      end
    end
  end

  -- New sum of points
  local simulatedPoints = calculatePoints(cardTable)

  -- Points gained from new cards
  local pointsGained = simulatedPoints - initialPoints
  -- 'Point totals added' message
  local pointMessage = 'Adding '..pointsGained..' to '..initialPoints..' for '..simulatedPoints..' points'
  -- Bonuses gained
  if #bonusCards > 0 then --There is at least a bonus
    local bonusMessage = '\nWith 4 of Kind of: '
    for _, card in pairs(bonusCards) do
      bonusMessage = bonusMessage..card..'s '
    end

    bonusMessage = bonusMessage..backupMessage -- If there was no backup, then backupMessage should be empty

    broadcastToAll(pointMessage..bonusMessage) -- Broadcast with bonusMessage (seems only one broadcast at a time)
  else
    broadcastToAll(pointMessage) -- Broadcast without bonusMessage
  end
  addRoundNote(playerColor..' gained '..pointsGained..' with '..#bonusCards..' 4 of Kind from '..numofCards..' cards '..backupMessage)
  return pointsGained
end

-- Bet
function playerBet(obj, color, alt_click)
  log('Player '..color..' bets')
  --log('Player Ace: '..players[color].wonCards['Ace']) -- To test wonCards working
  local betPlacement = players[color].betPos -- Bet button's place and bet card's place are the same
  --log('Placement of bet is: '..betPlacement[1]..' '..betPlacement[2]..' '..betPlacement[3])
  getDeck().takeObject({
    position = {-betPlacement[1],betPlacement[2],betPlacement[3]}, --Have to flip x cordinate because the takeObject position flips the x value
    rotation = {0,0,0},
    --callback_function = function,
    flip = true
  })
  players[color].bet_state = true
  deleteButtonHere(betPlacement)
end

-- Puts cards in field into discard zone
function clearField(obj, color)
  if players[color] == nil then
    broadcastToAll(PLAYER_HAS_NO_COLOR_BROADCAST_MESSAGE)
    log(PLAYER_HAS_NO_COLOR_LOG_MESSAGE)
    return
  end

  local zoneObjects = fieldZone.getObjects()
  local i = 0
  local discardZonePosition = discardZone.getPosition()
  local numCards = 0

  for _, item in pairs(zoneObjects) do
    if #item.getZones() == 2 and item.tag == 'Card' then
      numCards = numCards + 1
    end
  end

  addRoundNote('Clear '..numCards..' cards from the field.')

  for _, item in ipairs(zoneObjects) do -- Check each object in the zone
    if #item.getZones() == 2 then     -- If in only field zone and the zone surrounding the whole game (so doesn't grab deck)
      local randomXOffset = math.random(DISCARD_X_OFFSET * 2 + 1) - DISCARD_X_OFFSET;
      local randomYOffset = math.random(DISCARD_Y_OFFSET * 2 + 1) - DISCARD_Y_OFFSET;

      item.setPositionSmooth({discardZonePosition[1] + randomXOffset, discardZonePosition[2]+5+i, discardZonePosition[3] + randomYOffset}, false, true) -- Put cards above win pile at varying heights
      i = i + .8
    end
  end

  regenerateBetButtons()
end

--[[
ButtonActions.ttslua END
]]
